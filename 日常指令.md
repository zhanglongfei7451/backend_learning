

Pbm99SJ9LA)pJb* 

或

Pbm99SJ9LA)p*










```
Celery -A async worker -l info -P eventlet
```

```
Celery -A async worker -l info --pool=solo
```

```
celery flower -A async --address=127.0.0.1 --port=5555
```

bk-base/src/**dataweb**/bk_dataweb/src/config/domains.py

```python
DATAQUERY_APIGATEWAY_ROOT = BKDATA_ESB_PREFIX + "dataquery/"
BKDATA_ESB_PREFIX = PAAS_API_HOST + ESB_PREFIX + "data/v3/"
PAAS_API_HOST = settings.PAAS_API_HOST....ESB_PREFIX = "/api/c/compapi/"
```









1.bk-base/src/**api**/meta/urls.py

```python
url(r"^basic/", include(basic_urls)),
```

2.bk-base/src/**api**/meta/basic/urls.py

```python
url(r"complex_search", entity.ComplexSearchView.as_view()),
```

3.bk-base/src/**api**/meta/basic/entity.py

```python
class ComplexSearchView(RPCView):
    """
    @apiDefine EntityComplexSearch
    """

    """
    @api {post} /meta/basic/entity/complex_search 原生后端查询语言搜索。
    @apiName EntityComplexSearch
    @apiGroup Basic
    @apiVersion 0.1.0
    @apiUse EntityComplexSearch

    @apiParam {String} [statement] 查询语句。
    @apiParam {String="mysql","atlas"} [backend_type] 查询后端。

    @apiSuccessExample {json} Success-Response:
```













结果表    bk-base/src/api/meta/public/views/result_table.py

结果表路由   bk-base/src/api/meta/public/urls.py

结果表所在metaApp路由   bk-base/src/api/meta/urls.py























bk-base/src/dataweb/bk_dataweb/src/apps/dataflow/urls.py



http://data-govern-web.wlyywgzt.com:30324/?&#/dataflow/ide  数据治理开发环境
http://data-govern-web.bcopstest.com:30324/#/dataflow/ide/104?project_id=1049  数据治理测试环境
https://10.253.111.224:8081/iga/index.html 移动云4A平台
http://ci.cmss.com/#/login?redirect=%23%2FindexPage%2Ftoken   CI/CD



127.0.0.1       localhost 100.76.10.93 paas-test.wlyywgzt.com 100.76.10.93 cmdb-test.wlyywgzt.com 100.76.10.93 job-test.wlyywgzt.com 100.76.10.93 queryengine.wlyywgzt.com 100.76.10.93 jobapi.wlyywgzt.com 100.76.10.23 data-govern-web.wlyywgzt.com 100.76.10.105 test.wlyywgzt.com 10.253.171.224 data-govern-web.bcopstest.com 10.251.156.72 paas.bcopstest.com 10.251.156.70 paas.bcopstest.com 127.0.0.1 paas.bcopstest.com 10.174.186.5 ccops-paas.cmecloud.cn 10.174.186.6 ccops-paas.cmecloud.cn 10.172.234.3 ccops-paas.cmecloud.cn 10.172.234.4 ccops-paas.cmecloud.cn











## Dgraph
client---事务的发起者，网络客户端
Dgraph server----Dgraph http server，负责接收处理client的http读写请求





#linux下查询突变格式
curl -H "Content-Type: application/graphql+-" -X POST  -d $'{
 me(func: has(name)) {
   name 
   uid
 }
}' localhost:8080/query | python -m json.tool 







## Git
git init 初始化
git log
git log --pretty=oneline
git log --graph
git reflog
git add .  全部加入，也可以加一个文件名字
git commit -m '注释内容‘    暂存区内容到本地仓库
git status'
git reset --hard commitID 版本回退

git branch    查看分支
git branch 分支名      创建本地分支
git checkout 分支名      切换分支
git merge     分支名称
git branch -d 删除分支
git branch -r 查看远程分支

git remote add <远端名称，默认origin> <仓库路径>   初始化本地仓库并于已创建的远程仓库连接
git remote 查看远程仓库
git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]
远程分支和本地分支名称相同，则可以只写本地分支git push origin master;-f表示强制覆盖，--set-upstream 推送到远端的同时并且建立起和远端分支的关联关系git push --set-upstream origin master；如果当前分支已经和远端分支关联，则可以省略分支名和远端名。git push 将master分支推送到已关联的远端分支。
git branch -vv 查看本地分支和远端分支的关联
如果已经有一个远端仓库，我们可以直接clone到本地。
命令: git clone <仓库路径> [本地目录]
本地目录可以省略，会自动生成一个目录
git clone -b <指定分支名> <远程仓库地址>

 % 远程分支和本地分支名字最好保持一致，不然会有许多bug搞不清楚
#将本地分支上传到远端，同时关联newbranch和远端branch分支
git push --set-upstream origin newbranch:origin/branch
其中 origin是远程仓库别名，newbranch 是本地分支名 origin/branch是远程分支名

#将本地newbranch分支与远端branch分支关联。这种方式最为直接
git branch --set-upstream-to=origin/branch newbranch
git branch --unset-upstream 撤销分支关联
git push origin master     上传本地仓库到已关联的远端分支

远程分支和本地的分支一样，我们可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作
git fetch [remote name] [branch name] 抓取指令就是将仓库里的更新都抓取到本地，不会进行合并
git pull [remote name] [branch name]
拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge -

git pull origin main --allow-unrelated-histories 

//查询当前远程的版本
git remote -v
//获取最新代码到本地
git fetch origin master  [示例1：获取远端的origin/master分支]
git fetch origin dev [示例2：获取远端的origin/dev分支]
//查看版本差异
git log -p master..origin/master [示例1：查看本地master与远端origin/master的版本差异]
git log -p dev..origin/dev   [示例2：查看本地dev与远端origin/dev的版本差异]
//合并最新代码到本地分支
git merge origin/master  [示例1：合并远端分支origin/master到当前分支]
git merge origin/dev [示例2：合并远端分支origin/dev到当前分支]
最后在gitpush

注：
git pull和git fetch的区别
git  pull(拉取)  即从远程仓库抓取本地没有的修改并【自动合并】到远程分支     git pull origin master
git  fetch(提取) 从远程获取最新版本到本地不会自动合并   git fetch  origin master   
git diff 查看同一个文件的冲突



合并，合并的是历史操作




ssh-keygen -t rsa -C “1527732688@qq.com” -f ~/.ssh/github_rsa
#注意替换为自己注册的邮箱
ssh-keygen -t rsa -C "zhanglongfei@cmss.chinamobile.com”
#注意替换成自己的名字和邮箱
git config --global user.name "zhanglongfei"
git config --global user.email "zhanglongfei@cmss.chinamobile.com"

git config --global user.name

cd ../返回上级目录
dir查看当前所有目录



## Python



python -m venv myenv 在项目主目录下创建虚拟环境
进入到myenv/Scripts/activate激活虚拟环境
deactivate退出虚拟环境
rm -rf myenv删除虚拟环境

pip freeze > requirements.txt 生成依赖文件
pip install -r requirements.txt 安装依赖文件

C:\............\django-admin.exe startproject 项目名称
或者加入环境变量之后  django-admin startproject 项目名称









Celery -A Django_Demo worker -l info -P eventlet
Celery -A Django_Demo worker -l info --pool=solo 

python manage.py makemigrations
python manage.py migrate

python manage.py startapp myapp



## Django-DRF
### django基础

1. CRUD小应用——MVT架构模式
2. 模型——字段(基础字段、关系字段、on_delete删除选项、related_name选项)、MTEA选项、自定义方法、自定义Manager方法
3. ORM数据查询接口--增删改查、高级Q与F方法
4. 路由——path与re_path方法、reverse()反向解析，命名空间
5. 视图——通用类视图--前后端分离，不好使用了
6. 表单设计——自定义表单forms.Form和根据模型自动生成的表单forms.ModelForm，自定义表单进行clean验证
7. 分页与通用模板——Paginator
8. 上传文件与ajax交互未看
9. 配置文件

### django进阶

1. QuerySet惰性查询，选择合适的方法(比如exists,count,update,values)减少数据库的全量访问
1. 中间件Middleware——功能为全局性
1. Signals信号机制——自定义或者全局信号，不同事件的联动，发掘应用场景

### DRF
1. 改变序列化输出内容:
    指定source、自定义序列化方法、to_representation()
2. 嵌套序列化器
    使用嵌套函数或者设置关联模型的深度
3. 关系序列化
4. 数据验证
	字段级别验证和对象级别验证、序列化器
5. 重写序列化器中的create和update方法


## linux



## docke
