## 网关

```
“GATEWAY=192.168.176.2”指定了该网络的网关IP地址为192.168.176.2。当本地网络中的设备想要与本网络之外的设备进行通信时，它们会通过这个网关地址发送数据流量
```




## 局域网

```
本地网络（Local Network），通常是指在一个有限地理范围内的计算机和其他设备（如打印机、路由器、交换机等）通过有线或无线方式互相连接起来形成的网络，也称为局域网（LAN, Local Area Network）

局域网（Local Area Network, LAN）中使用的IP地址具有以下特点：

1. **私有地址范围**： 局域网内常常使用私有IP地址，这些地址不会在全球互联网上唯一标识设备，而是仅在本地网络内部有效。常见的私有IP地址范围包括：
   - A类：10.0.0.0/8（10.0.0.0到10.255.255.255）
   - B类：172.16.0.0/12（172.16.0.0到172.31.255.255）
   - C类：192.168.0.0/16（192.168.0.0到192.168.255.255）
2. **唯一性**： 在同一局域网内，每台设备的IP地址必须是唯一的，以确保数据能够准确地发送到目标设备。
3. **自动分配与静态分配**： 局域网中的IP地址可以通过DHCP（Dynamic Host Configuration Protocol）服务器动态分配，也可以手动设置为静态IP地址。
4. **子网划分**： 局域网内的IP地址通常会结合子网掩码进行子网划分，用于管理和区分不同的网络段，每个子网内的设备可以互相直接通信，而不同子网间则需要通过路由器转发。
5. **路由功能**： 局域网中的默认网关或路由器的接口将配置一个特殊的IP地址，它是连接到外部网络（如广域网或Internet）的出口，所有发往非本网段的数据包都需要通过这个网关转发。
6. **网络拓扑适应性**： 局域网中的IP地址配置不受特定网络拓扑结构限制，可以在总线型、环形、星型、树状等各种拓扑结构中使用。

总结起来，局域网IP地址的主要特点是其在特定范围内保持唯一，并且可以根据实际需求灵活分配和管理，同时支持多种网络配置和架构设计。



```





## 子网

```
192.168.1.0/24 这个表示法是CIDR（Classless Inter-Domain Routing，无类别域间路由）记法，用于表示IPv4地址和其相关的子网掩码信息。在这个例子中：

192.168.1.0 是IP地址部分，它标识了网络中的一个特定网络的起始地址。
/24 表示该网络的前缀长度或者网络位数，即在IP地址中共有24位用于标识网络部分。
由于默认C类IP地址的子网掩码为 255.255.255.0，它的二进制形式是32位中有连续的24个“1”，对应着IP地址中前24位为网络号，后8位为主机号。因此，当看到 /24 时，可以直接推断出对应的子网掩码是 255.255.255.0。

这个格式告诉我们，从 192.168.1.0 开始到 192.168.1.255 结束的整个范围属于同一个网络段，其中：

192.168.1.0 是网络地址，不能分配给主机使用；
192.168.1.255 是广播地址，同样不能分配给主机使用；
在这个范围内可用的主机地址是从 192.168.1.1 到 192.168.1.254。



如果要将 192.168.1.0/24 这个C类网络划分为3个子网，我们需要从原有的8位主机位中借用一些位来作为子网位。为了方便划分，我们至少需要借用两位（因为2的2次方等于4，可以提供4个子网，其中两个子网保留为未来扩展或特殊用途）。
假设我们借用两位主机位，则新的子网掩码会是 /26（即前26位表示网络和子网），对应的子网掩码为 255.255.255.192（二进制表示为 11111111 11111111 11111111 11000000）。
这样划分后，每个子网包含的可用IP地址数量为 (2^6 - 2)（减去全0和全1的子网地址和广播地址），即每个子网有62个可用地址。

以下是三个子网的具体范围：
子网1：192.168.1.0/26，地址范围：192.168.1.0 到 192.168.1.63 网络地址：192.168.1.0，广播地址：192.168.1.63
子网2：192.168.1.64/26，地址范围：192.168.1.64 到 192.168.1.127 网络地址：192.168.1.64，广播地址：192.168.1.127
子网3：192.168.1.128/26，地址范围：192.168.1.128 到 192.168.1.191 网络地址：192.168.1.128，广播地址：192.168.1.191
以上就是将 192.168.1.0/24 C类网络划分为3个 /26 子网的具体情况。

在IPv4的子网划分中，网络前缀长度（即CIDR记法中的“/”后面跟随的数字）必须是1到32之间的整数，表示从IP地址左边开始计算的连续的“1”的位数。例如，在C类地址 192.168.1.0 中，原始的网络前缀长度为 /24，这意味着有24位用于网络部分。
如果要划分成更小的子网，我们需要借用主机ID的部分位数作为子网ID。但你提到的“23/”这种划分方式并不存在，因为前缀长度不能是23，它不满足从左到右连续的“1”有特定数量的要求。
如果你的意思是在询问能否只借用一位主机位来划分子网，理论上是可以的，但是那样只能得到两个子网，对于需要三个子网的情况来说不够用。所以通常情况下我们会选择借用两位或更多位来确保能够得到足够数量的子网。在这种场景下，为了划分为3个子网，至少需要借用两位主机位，从而得到 /26 的网络前缀长度。



实际上，192.168.0.0/16 是一个B类网络地址范围，并非C类。在IPv4中，B类网络的默认子网掩码是 255.255.0.0，这意味着前16位用于标识网络部分，后16位用于主机部分。

要将这个B类地址划分为三个子网，我们可以借用主机部分的高位来作为子网位。由于可用的主机位有16位，所以有足够的空间来划分多个子网。

例如，为了划分成三个子网，我们至少需要借用两位主机位，这样可以得到 2^2 = 4 个子网（包括全0和全1保留的情况）。但实际上我们需要的是3个有效子网，因此可以选择借用3位，这样就可以得到 2^3 = 8 个子网，然后选择其中连续的3个子网使用。

假设借用3位主机位，新的子网掩码会是 /19，即 255.255.224.0。接下来，根据这个子网掩码，我们可以计算出每个子网的范围：

子网1：192.168.0.0/19，IP地址范围从 192.168.0.0 到 192.168.31.255
子网2：192.168.32.0/19，IP地址范围从 192.168.32.0 到 192.168.63.255
子网3：192.168.64.0/19，IP地址范围从 192.168.64.0 到 192.168.95.255
请注意，上述划分方法提供了额外的剩余子网以供未来扩展。如果只需要三个子网并且不关心是否能获得更多子网，则可以只借用两位主机位并创建四个子网，然后只使用其中的三个。在这种情况下，新的子网掩码将是 /20，而具体的子网范围将会有所不同。
```



## 路由

```json
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.241.143  netmask 255.255.255.0  broadcast 192.168.241.255
        inet6 fe80::8727:c7b0:a6cf:3d8c  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:06:af:6a  txqueuelen 1000  (Ethernet)
        RX packets 159023  bytes 11595917 (11.0 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 295093  bytes 594103513 (566.5 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

ens37: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.20.222.138  netmask 255.255.248.0  broadcast 172.20.223.255
        inet6 2409:8720:4a00:1402:68fb:ff3e:d161:598a  prefixlen 64  scopeid 0x0<global>
        inet6 fe80::1e0c:1d37:2005:146  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:06:af:74  txqueuelen 1000  (Ethernet)
        RX packets 3526746  bytes 946792782 (902.9 MiB)
        RX errors 0  dropped 2455  overruns 0  frame 0
        TX packets 2591298  bytes 575315486 (548.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


default via 172.20.223.254 dev ens37 proto dhcp metric 101
169.254.0.0/16 dev ens37 scope link metric 1005
172.20.216.0/21 dev ens37 proto kernel scope link src 172.20.222.138 metric 101
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1
192.168.241.0/24 dev ens33 proto kernel scope link src 192.168.241.143 metric 100

第一行:
这行表示默认路由（default route），所有非本地网络的数据包都将通过ens37接口转发到下一跳地址 172.20.223.254。proto dhcp 表示该路由是由DHCP服务器动态分配的，metric 101 是这条路由的成本或优先级。

第二行:
169.254.0.0/16 dev ens37 scope link metric 1005
这是一条自动配置（APIPA）地址范围的路由条目，适用于当主机无法通过DHCP获取IP地址时自动生成一个链接本地地址的情况。scope link 指定此路由仅在直接相连的链路上有效。

第三行：
172.20.216.0/21 dev ens37 proto kernel scope link src 172.20.222.138 metric 101
这是一条主机路由，针对 172.20.216.0/21 网络段的数据包将通过 ens37 接口进行处理，并且在这个子网内，主机本身的IP地址为 172.20.222.138，metric 101 是其优先级。

第四行：
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1
这也是一条主机路由，对于目标网络 192.168.122.0/24 的数据包，它们会通过虚拟网桥设备 virbr0 传递，源IP地址为 192.168.122.1，主要用于管理虚拟机环境中的网络通信。

第五行：
192.168.241.0/24 dev ens33 proto kernel scope link src 192.168.241.143 metric 100
同样是一条主机路由，表示 192.168.241.0/24 网络段的数据包通过 ens33 接口发送，本地设备在这个子网内的IP地址为 192.168.241.143，并且 metric 100 表示它比其他同子网的更高优先级路由有更低的成本。

```





## 掩码

```
NETMASK="255.255.255.0" 这个设置定义了网络掩码（Network Mask），在计算机网络中，它用来确定IP地址中的哪些部分代表网络地址，哪些部分代表主机地址。

具体到这个例子：

255.255.255.0 对应的二进制表示是 11111111 11111111 11111111 00000000。
其中连续的1表示网络部分，连续的0表示主机部分。
对于IPv4地址来说，这种掩码通常对应的是C类地址的默认子网掩码，意味着前24位用于标识网络号，后8位用于标识主机号。
例如，如果一个IP地址为 192.168.1.1 并且使用上述的子网掩码，则它的网络地址就是 192.168.1.0，在这个网络内的其他设备其IP地址的第一、第二和第三部分必须与 192.168.1 相同，而第四部分（主机部分）则可以在 0 到 255 的范围内变化。
```

## ARP

```JSON
# 同一局域网
ARP（Address Resolution Protocol，地址解析协议）是TCP/IP网络中用于在链路层（以太网、令牌环等）将IP地址映射到物理（MAC）地址的一种协议。以下是ARP地址解析的基本过程：

请求阶段：

当主机A需要与同一局域网内的主机B通信时，首先要知道主机B的MAC地址。
如果主机A的ARP缓存表中没有主机B的MAC地址记录，主机A会构造一个ARP请求广播帧，该帧中包含了目标IP地址（即主机B的IP地址）和源IP地址（主机A的IP地址），但目标MAC地址部分填充为全F（FF:FF:FF:FF:FF:FF），表示这是一个广播请求。
响应阶段：

ARP请求广播帧被同一个局域网中的所有设备接收到，包括主机B。
主机B检查ARP请求中的目标IP地址是否与自己的IP地址匹配。
若匹配，则主机B会发送一个单播ARP响应帧给主机A，其中包含了自己的MAC地址以及主机A的IP地址。
缓存记录：

主机A收到ARP响应后，提取出主机B的MAC地址，并将其存储在ARP缓存表中，以便后续可以直接使用这个MAC地址来发送数据包。
缓存中的ARP条目通常有一个有限的生存时间（TTL），过期后会自动删除或更新。
通过上述步骤，主机A成功地通过ARP协议获取到了主机B的物理地址，从而能够在数据链路层上直接与主机B进行通信。




# 不同的局域网中
ARP协议不能直接跨网络工作。如果主机A需要与不同局域网中的主机B通信，则需要通过以下方式实现：

默认网关：

如果主机A和主机B不在同一个子网（即同一局域网）内，主机A通常会将数据包发送给其默认网关（通常是路由器），因为默认网关连接了多个局域网。
主机A首先使用ARP请求获取默认网关的MAC地址，然后将目标为主机B的数据包发送给默认网关。
路由转发：

路由器收到主机A的数据包后，查看其内部的路由表以决定如何转发该数据包。
如果路由器知道如何到达主机B所在的子网，它将根据路由表更新IP头部的目的地址，并通过另一个接口将数据包发送到下一个跃点（可能是另一个路由器或主机B所在子网的交换机）。
目的地局域网的ARP解析：

数据包到达主机B所在子网后，子网内的设备（如交换机或路由器）会广播ARP请求来找到主机B的实际MAC地址。
主机B回应ARP请求，提供其MAC地址，这样数据包就可以最终送达主机B。
总结来说，在不同局域网间进行通信时，ARP主要用于本地子网内的设备寻址，而跨子网通信则依赖于路由器的路由功能和逐跳地进行ARP解析。


14:27:54.818912 ARP, Request who-has localhost.localdomain tell 192.168.241.150, length 46
14:27:54.818937 ARP, Reply localhost.localdomain is-at 00:0c:29:06:af:6a (oui Unknown), length 28
```

## ICMP ping

```
ICMP ping测试是一种利用Internet Control Message Protocol (ICMP) 的Echo请求和Echo回复消息来检测网络连通性、延迟和数据包丢失情况的方法。在命令行中，通常使用ping命令来进行这项测试。以下是一个基本的ICMP ping测试流程：

发起Ping请求： 当你在一台主机上执行ping <目标IP地址>时，本地主机将发送一个ICMP Echo请求报文到指定的目标主机。

接收Echo回复： 目标主机收到Echo请求后，会返回一个ICMP Echo回复报文给发起请求的主机。

测量指标：

连通性：如果能够接收到Echo回复，则表明两台主机之间网络是连通的。
延迟（Round-Trip Time, RTT）：根据Echo请求发出时间和Echo回复到达时间计算往返时间，即数据包在网络中传输的时间。
丢包率：如果发送了多个Echo请求但没有收到全部回复，则说明发生了数据包丢失。
持续测试： ping命令默认会持续不断地发送Echo请求，直到被手动停止（通过按Ctrl+C键中断），或者达到指定的次数或超时。



ping -c 1 192.168.241.143

tcpdump -i ens33 host 192.168.241.150
14:28:04.838077 IP 192.168.241.150 > localhost.localdomain: ICMP echo request, id 19924, seq 1, length 64
14:28:04.838179 IP localhost.localdomain > 192.168.241.150: ICMP echo reply, id 19924, seq 1, length 64
```

## 回环接口

```
这段配置信息来自于Linux系统中用于定义回环接口（Loopback Interface）的配置文件ifcfg-lo。下面是对各个配置项的解释：

DEVICE=lo: 定义了设备名称为“lo”，这是回环接口的标准设备名。

IPADDR=127.0.0.1: 为回环接口分配了IPv4地址127.0.0.1，这是一个保留地址，通常称为localhost，任何发往这个地址的数据包都会被发送给本地主机本身。

NETMASK=255.0.0.0: 网络掩码设置为255.0.0.0。在这个案例中，配置可能有误，标准的回环接口网络掩码应该是255.0.0.0/8，即255.0.0.0，但通常在现代Linux系统中会自动纠正为正确的掩码255.0.0.0（或简写为/8）。

NETWORK=127.0.0.0: 指定网络地址为127.0.0.0，这也是回环地址所在的网络段。

BROADCAST=127.255.255.255: 设置广播地址为127.255.255.255。对于回环接口而言，这个广播地址的实际作用并不明显，因为回环接口主要用于本机内部通信。

ONBOOT=yes: 表示在系统启动时自动激活此回环接口。

NAME=loopback: 给接口赋予一个友好的名称，这里命名为"loopback"，表示它是一个回环接口。

总之，ifcfg-lo 文件是用来配置和管理Linux系统中的回环网络接口的，确保在系统启动时该接口可用，并正确指定了其IP地址、网络掩码等相关属性。
```








## 1. 网络检测工具

### 1.1 traceroute

traceroute是一个用于追踪数据包从本地主机到目标主机所经过的路由（即IP地址）的命令行工具。

在Linux系统中，执行以下命令：

```
traceroute www.baidu.com
```

这将显示数据包到达`www.baidu.com`的过程中经过的所有路由器及其响应时间。每个“跳”代表一个网络节点，通常包括路由器、交换机或任何参与数据包转发的设备。

### 1.2 tcpdump

`tcpdump` 命令有很多选项和参数，以下是一些基本且常用的 `tcpdump` 命令格式及其含义：

1. **捕获所有网络流量**：

```code
tcpdump
```

这将监听默认网卡上的所有IP流量。

**指定网络接口**：

```
tcpdump -i [interface]
```

例如：`tcpdump -i eth0`，这将只捕获eth0网卡上的流量。

**过滤特定主机或网络**：

```
tcpdump host [host/IP address]
```

或者使用网络掩码来指定一个网络范围：

```
tcpdump net [network/IP address/mask]
```

**按照协议过滤**：

```
tcpdump proto [protocol]
```

如：`tcpdump proto tcp` 只捕获TCP协议的流量。

**根据端口过滤**：

```
tcpdump port [port number]
```

如：`tcpdump port 80` 仅显示HTTP（默认端口为80）相关的数据包。

**输出到文件**：

```
tcpdump -w [file]
```

将捕获的数据包保存到指定的文件中，以便后续分析。

**从文件读取并解析数据包**：

```
tcpdump -r [file]
```

**打印数据包内容**：

```
tcpdump -A
```

显示数据包的ASCII内容（如果有的话）。

**只显示匹配的数据包数**：

1. ```code
   tcpdump -c [count]
   ```

   指定捕获指定数量的数据包后停止。

这只是 `tcpdump` 命令的一部分功能，实际使用时可以根据需要组合各种选项进行更加精细的筛选和监控。在使用 `tcpdump` 时，请确保你有足够权限，并遵守相关法律法规，尤其是在生产环境中进行网络抓包时。

### 1.3 top 

### 1.4 df -h



## 2. 一台机器作为另一台机器的网关

如果143机器需要作为其他内部网络主机（如149机器）访问外部网络的网关，您需要在143机器上执行以下操作：

1. **检查143机器的网络接口和路由配置**： 确保 `ens37` 接口已连接到互联网，并且具有正确的IP地址、子网掩码和默认网关设置。

2. **启用IP转发**： IP转发已经在您的系统中启用，无需再次执行此步骤。

3. **配置NAT (网络地址转换)**： 使用iptables工具为从 `192.168.241.0/24` 子网来的流量配置SNAT（源地址转换），使其能够通过 `ens37` 接口访问外部网络。以下是示例命令：

```
# 允许转发
sudo iptables -P FORWARD ACCEPT

# 添加POSTROUTING链规则以进行SNAT
sudo iptables -t nat -A POSTROUTING -s 192.168.241.0/24 ! -d 192.168.241.0/24 -j SNAT --to-source 192.168.1.8
```
上述命令会将来自 `192.168.241.0/24` 子网并要发送到外部网络的数据包的源地址转换为 `192.168.1.8`。
**保存iptables规则**： 在某些Linux发行版中，重启后iptables规则可能会丢失，所以需要确保规则被持久化保存。方法如下：

对于RHEL/CentOS 7及以前版本：
  ```
  bash
  sudo service iptables save
  ```
对于较新版本或需要手动保存的情况：

1. ```bash
   sudo iptables-save > /etc/sysconfig/iptables
   ```
   
2. **确认防火墙策略**： 虽然您提到firewalld已经关闭，但还需确保没有其他的防火墙规则阻止了数据包的转发。如果您使用的是iptables以外的防火墙管理工具，请根据对应工具文档进行相应配置。

3. ```bash
   若是直接修改的iptables，则需要执行下面的文件时iptables生效
   
   # 使用iptables直接应用规则
   sudo iptables-restore < /etc/sysconfig/iptables
   ```



完成上述步骤后，理论上149机器应该可以通过143机器访问外部网络。但是请注意，实际环境可能有额外的安全性和网络架构考量，务必谨慎配置。

```text
还有配一下
#打开路由转发功能
[root@stache31 ~]# echo 'net.ipv4.ip_forward = 1' >> /etc/sysctl.conf
[root@stache31 ~]# sysctl -p
再检查一下/etc/resolv.conf文件中是否设置nameserver
```

