## 防火墙

```json
Linux系统中使用iptables -L命令查看防火墙规则的结果。以下是各个部分的解释：

INPUT链 (Chain INPUT)：所有进入系统的网络数据包首先经过INPUT链处理，当前配置显示该链的默认策略是接受（ACCEPT）所有数据包。

FORWARD链 (Chain FORWARD)：用于处理需要在本机转发的数据包。目前有5条规则：

DOCKER-USER 链：用于对Docker容器用户自定义的规则进行处理。
DOCKER-ISOLATION-STAGE-1 链：Docker隔离阶段1，通常用来防止未授权的通信。
接受从任何地方来，并且状态为RELATED或ESTABLISHED的数据包。
专用于Docker容器的规则处理。
再次接受所有其他数据包。

OUTPUT链 (Chain OUTPUT)：所有离开系统的网络数据包将经过OUTPUT链，默认策略也是接受所有数据包。

```





## 网关

```
“GATEWAY=192.168.176.2”指定了该网络的网关IP地址为192.168.176.2。当本地网络中的设备想要与本网络之外的设备进行通信时，它们会通过这个网关地址发送数据流量
```




## 局域网

```
本地网络（Local Network），通常是指在一个有限地理范围内的计算机和其他设备（如打印机、路由器、交换机等）通过有线或无线方式互相连接起来形成的网络，也称为局域网（LAN, Local Area Network）

局域网（Local Area Network, LAN）中使用的IP地址具有以下特点：

1. **私有地址范围**： 局域网内常常使用私有IP地址，这些地址不会在全球互联网上唯一标识设备，而是仅在本地网络内部有效。常见的私有IP地址范围包括：
   - A类：10.0.0.0/8（10.0.0.0到10.255.255.255）
   - B类：172.16.0.0/12（172.16.0.0到172.31.255.255）
   - C类：192.168.0.0/16（192.168.0.0到192.168.255.255）
2. **唯一性**： 在同一局域网内，每台设备的IP地址必须是唯一的，以确保数据能够准确地发送到目标设备。
3. **自动分配与静态分配**： 局域网中的IP地址可以通过DHCP（Dynamic Host Configuration Protocol）服务器动态分配，也可以手动设置为静态IP地址。
4. **子网划分**： 局域网内的IP地址通常会结合子网掩码进行子网划分，用于管理和区分不同的网络段，每个子网内的设备可以互相直接通信，而不同子网间则需要通过路由器转发。
5. **路由功能**： 局域网中的默认网关或路由器的接口将配置一个特殊的IP地址，它是连接到外部网络（如广域网或Internet）的出口，所有发往非本网段的数据包都需要通过这个网关转发。
6. **网络拓扑适应性**： 局域网中的IP地址配置不受特定网络拓扑结构限制，可以在总线型、环形、星型、树状等各种拓扑结构中使用。

总结起来，局域网IP地址的主要特点是其在特定范围内保持唯一，并且可以根据实际需求灵活分配和管理，同时支持多种网络配置和架构设计。



```





## 子网

```
192.168.1.0/24 这个表示法是CIDR（Classless Inter-Domain Routing，无类别域间路由）记法，用于表示IPv4地址和其相关的子网掩码信息。在这个例子中：

192.168.1.0 是IP地址部分，它标识了网络中的一个特定网络的起始地址。
/24 表示该网络的前缀长度或者网络位数，即在IP地址中共有24位用于标识网络部分。
由于默认C类IP地址的子网掩码为 255.255.255.0，它的二进制形式是32位中有连续的24个“1”，对应着IP地址中前24位为网络号，后8位为主机号。因此，当看到 /24 时，可以直接推断出对应的子网掩码是 255.255.255.0。

这个格式告诉我们，从 192.168.1.0 开始到 192.168.1.255 结束的整个范围属于同一个网络段，其中：

192.168.1.0 是网络地址，不能分配给主机使用；
192.168.1.255 是广播地址，同样不能分配给主机使用；
在这个范围内可用的主机地址是从 192.168.1.1 到 192.168.1.254。



如果要将 192.168.1.0/24 这个C类网络划分为3个子网，我们需要从原有的8位主机位中借用一些位来作为子网位。为了方便划分，我们至少需要借用两位（因为2的2次方等于4，可以提供4个子网，其中两个子网保留为未来扩展或特殊用途）。
假设我们借用两位主机位，则新的子网掩码会是 /26（即前26位表示网络和子网），对应的子网掩码为 255.255.255.192（二进制表示为 11111111 11111111 11111111 11000000）。
这样划分后，每个子网包含的可用IP地址数量为 (2^6 - 2)（减去全0和全1的子网地址和广播地址），即每个子网有62个可用地址。

以下是三个子网的具体范围：
子网1：192.168.1.0/26，地址范围：192.168.1.0 到 192.168.1.63 网络地址：192.168.1.0，广播地址：192.168.1.63
子网2：192.168.1.64/26，地址范围：192.168.1.64 到 192.168.1.127 网络地址：192.168.1.64，广播地址：192.168.1.127
子网3：192.168.1.128/26，地址范围：192.168.1.128 到 192.168.1.191 网络地址：192.168.1.128，广播地址：192.168.1.191
以上就是将 192.168.1.0/24 C类网络划分为3个 /26 子网的具体情况。

在IPv4的子网划分中，网络前缀长度（即CIDR记法中的“/”后面跟随的数字）必须是1到32之间的整数，表示从IP地址左边开始计算的连续的“1”的位数。例如，在C类地址 192.168.1.0 中，原始的网络前缀长度为 /24，这意味着有24位用于网络部分。
如果要划分成更小的子网，我们需要借用主机ID的部分位数作为子网ID。但你提到的“23/”这种划分方式并不存在，因为前缀长度不能是23，它不满足从左到右连续的“1”有特定数量的要求。
如果你的意思是在询问能否只借用一位主机位来划分子网，理论上是可以的，但是那样只能得到两个子网，对于需要三个子网的情况来说不够用。所以通常情况下我们会选择借用两位或更多位来确保能够得到足够数量的子网。在这种场景下，为了划分为3个子网，至少需要借用两位主机位，从而得到 /26 的网络前缀长度。



实际上，192.168.0.0/16 是一个B类网络地址范围，并非C类。在IPv4中，B类网络的默认子网掩码是 255.255.0.0，这意味着前16位用于标识网络部分，后16位用于主机部分。

要将这个B类地址划分为三个子网，我们可以借用主机部分的高位来作为子网位。由于可用的主机位有16位，所以有足够的空间来划分多个子网。

例如，为了划分成三个子网，我们至少需要借用两位主机位，这样可以得到 2^2 = 4 个子网（包括全0和全1保留的情况）。但实际上我们需要的是3个有效子网，因此可以选择借用3位，这样就可以得到 2^3 = 8 个子网，然后选择其中连续的3个子网使用。

假设借用3位主机位，新的子网掩码会是 /19，即 255.255.224.0。接下来，根据这个子网掩码，我们可以计算出每个子网的范围：

子网1：192.168.0.0/19，IP地址范围从 192.168.0.0 到 192.168.31.255
子网2：192.168.32.0/19，IP地址范围从 192.168.32.0 到 192.168.63.255
子网3：192.168.64.0/19，IP地址范围从 192.168.64.0 到 192.168.95.255
请注意，上述划分方法提供了额外的剩余子网以供未来扩展。如果只需要三个子网并且不关心是否能获得更多子网，则可以只借用两位主机位并创建四个子网，然后只使用其中的三个。在这种情况下，新的子网掩码将是 /20，而具体的子网范围将会有所不同。
```



## 路由

```json
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.241.143  netmask 255.255.255.0  broadcast 192.168.241.255
        inet6 fe80::8727:c7b0:a6cf:3d8c  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:06:af:6a  txqueuelen 1000  (Ethernet)
        RX packets 159023  bytes 11595917 (11.0 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 295093  bytes 594103513 (566.5 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

ens37: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.20.222.138  netmask 255.255.248.0  broadcast 172.20.223.255
        inet6 2409:8720:4a00:1402:68fb:ff3e:d161:598a  prefixlen 64  scopeid 0x0<global>
        inet6 fe80::1e0c:1d37:2005:146  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:06:af:74  txqueuelen 1000  (Ethernet)
        RX packets 3526746  bytes 946792782 (902.9 MiB)
        RX errors 0  dropped 2455  overruns 0  frame 0
        TX packets 2591298  bytes 575315486 (548.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


default via 172.20.223.254 dev ens37 proto dhcp metric 101
169.254.0.0/16 dev ens37 scope link metric 1005
172.20.216.0/21 dev ens37 proto kernel scope link src 172.20.222.138 metric 101
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1
192.168.241.0/24 dev ens33 proto kernel scope link src 192.168.241.143 metric 100

第一行:
这行表示默认路由（default route），所有非本地网络的数据包都将通过ens37接口转发到下一跳地址 172.20.223.254。proto dhcp 表示该路由是由DHCP服务器动态分配的，metric 101 是这条路由的成本或优先级。

第二行:
169.254.0.0/16 dev ens37 scope link metric 1005
这是一条自动配置（APIPA）地址范围的路由条目，适用于当主机无法通过DHCP获取IP地址时自动生成一个链接本地地址的情况。scope link 指定此路由仅在直接相连的链路上有效。

第三行：
172.20.216.0/21 dev ens37 proto kernel scope link src 172.20.222.138 metric 101
这是一条主机路由，针对 172.20.216.0/21 网络段的数据包将通过 ens37 接口进行处理，并且在这个子网内，主机本身的IP地址为 172.20.222.138，metric 101 是其优先级。

第四行：
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1
这也是一条主机路由，对于目标网络 192.168.122.0/24 的数据包，它们会通过虚拟网桥设备 virbr0 传递，源IP地址为 192.168.122.1，主要用于管理虚拟机环境中的网络通信。

第五行：
192.168.241.0/24 dev ens33 proto kernel scope link src 192.168.241.143 metric 100
同样是一条主机路由，表示 192.168.241.0/24 网络段的数据包通过 ens33 接口发送，本地设备在这个子网内的IP地址为 192.168.241.143，并且 metric 100 表示它比其他同子网的更高优先级路由有更低的成本。


.254结尾的IP地址经常被用作子网内的默认网关地址，即路由器在该子网上的接口地址，负责连接内部网络与外部网络之间的通信
.255作为最后一个可分配的IP地址，代表了本网段的所有主机，当数据包被发送到这个地址时，所有该子网中的设备都会接收到这个广播信息。
```

```json
[root@szjd-csy-vm-os01-zhuangxiang-jiangxi-001 ~]# ip route show
# 这行表示所有非本地网络的数据包都将通过网关 10.253.217.254，并从接口 bond0.1677 发送出去。"proto static" 表示这是一个静态配置的路由，默认路由的优先级较高（metric为403）。
        default via 10.253.217.254 dev bond0.1677 proto static metric 403 
# 所有目标地址在 2.4.0.0/17 网络范围内的数据包将通过网关 10.253.227.254 并通过接口 bond1.1944 转发。
        2.4.0.0/17 via 10.253.227.254 dev bond1.1944 proto static metric 400 
        10.251.143.9 via 10.253.227.254 dev bond1.1944 
# 这些路由表示本机直接连接到这些网络段，并且不需要通过其他路由器发送数据包。其中，src 字段显示的是该网络接口的IP地址
        10.253.217.0/24 dev bond0.1677 proto kernel scope link src 10.253.217.136 metric 403 
        10.253.227.192/26 dev bond1.1944 proto kernel scope link src 10.253.227.203 metric 400 
        10.253.228.192/26 dev bond2.1945 proto kernel scope link src 10.253.228.203 metric 407 
# 这些路由规则对应单个IP地址，当目标地址匹配时，数据包会通过相同的网关和接口转发。
        100.70.48.32 via 10.253.227.254 dev bond1.1944 
        100.70.48.33 via 10.253.227.254 dev bond1.1944 
        100.70.48.34 via 10.253.227.254 dev bond1.1944 
        100.70.48.35 via 10.253.227.254 dev bond1.1944 
        100.70.48.37 via 10.253.227.254 dev bond1.1944 
        100.70.49.34 via 10.253.227.254 dev bond1.1944 
        100.71.31.37 via 10.253.227.254 dev bond1.1944 
# Docker容器网络
        172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
        211.136.17.106 via 10.253.227.254 dev bond1.1944
 
```

```json

```

## bond

```json
[root@szjd-csy-vm-os01-zhuangxiang-jiangxi-001 ~]# ifconfig

# bond0, bond1 和 bond2 这些是绑定（Bonding）网络接口，用于将多个物理网络接口组合在一起提供冗余、负载均衡或提高带宽。它们分别被配置为主动-主动模式（MASTER），并且都处于UP状态，可以正常接收和发送数据包
bond0: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST>  mtu 1500
        ether a8:c9:8a:2a:26:51  txqueuelen 1000  (Ethernet)
        RX packets 9330959261  bytes 1162764722575 (1.0 TiB)
        RX errors 0  dropped 0  overruns 88627471  frame 0
        TX packets 6053080205  bytes 969035124898 (902.4 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
bond1: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST>  mtu 1500
        ether 98:a9:2d:b1:a3:9c  txqueuelen 1000  (Ethernet)
        RX packets 414296763996  bytes 51803255730129 (47.1 TiB)
        RX errors 0  dropped 11224973  overruns 0  frame 0
        TX packets 377771955900  bytes 75028160089205 (68.2 TiB)
        TX errors 0  dropped 12 overruns 0  carrier 0  collisions 0
bond2: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST>  mtu 1500
        ether 98:a9:2d:1b:80:16  txqueuelen 1000  (Ethernet)
        RX packets 57743878  bytes 41416785102 (38.5 GiB)
        RX errors 0  dropped 278  overruns 0  frame 0
        TX packets 3884664  bytes 391551569 (373.4 MiB)
        TX errors 0  dropped 3 overruns 0  carrier 0  collisions 0

# bond0.1677, bond1.1944 和 bond2.1945 这些是bond0、bond1和bond2的子接口（或虚拟接口），每个都有其独立的IP地址、子网掩码以及广播地址，并且也都处于活动状态（UP）。这些子接口提供了在不同子网中的通信能力
bond0.1677: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.253.217.136  netmask 255.255.255.0  broadcast 10.253.217.255
        inet6 2409:8c20:1833:2000::afd:d988  prefixlen 120  scopeid 0x0<global>
        inet6 fe80::9950:aa9e:2e10:691f  prefixlen 64  scopeid 0x20<link>
        ether a8:c9:8a:2a:26:51  txqueuelen 1000  (Ethernet)
        RX packets 9024941043  bytes 1017263326220 (947.4 GiB)
        RX errors 0  dropped 2058  overruns 0  frame 0
        TX packets 6000626008  bytes 965602085283 (899.2 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
bond1.1944: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.253.227.203  netmask 255.255.255.192  broadcast 10.253.227.255
        inet6 2409:8c20:1833:2000::afd:e3cb  prefixlen 122  scopeid 0x0<global>
        inet6 fe80::fa8a:e005:6a72:7e6  prefixlen 64  scopeid 0x20<link>
        ether 98:a9:2d:b1:a3:9c  txqueuelen 1000  (Ethernet)
        RX packets 414270689697  bytes 46001232231980 (41.8 TiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 377769322719  bytes 75023599701347 (68.2 TiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
bond2.1945: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.253.228.203  netmask 255.255.255.192  broadcast 10.253.228.255
        inet6 fe80::e3b3:1bb8:b88a:391a  prefixlen 64  scopeid 0x20<link>
        inet6 2409:8c20:1833:2000::afd:e4cb  prefixlen 122  scopeid 0x0<global>
        ether 98:a9:2d:1b:80:16  txqueuelen 1000  (Ethernet)
        RX packets 37681791  bytes 38786218825 (36.1 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59795  bytes 3746090 (3.5 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
# 这是Docker守护进程创建的一个虚拟以太网桥，用于容器间的通信以及容器与宿主机之间的通信。当前该接口未启用（DOWN状态
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fe80::4c1d:a0c1:3cc4:e45c  prefixlen 64  scopeid 0x20<link>
        ether 02:42:c7:0c:f9:8d  txqueuelen 0  (Ethernet)
        RX packets 18858260  bytes 1265444275 (1.1 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 19064773  bytes 2809721183 (2.6 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

# eno1 和 eno2 这两个是以太网接口，可能为服务器上的物理网卡，目前作为bond0的从属接口（SLAVE）参与绑定
eno1: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST>  mtu 1500
        ether a8:c9:8a:2a:26:51  txqueuelen 1000  (Ethernet)
        RX packets 9051550979  bytes 1145638210097 (1.0 TiB)
        RX errors 0  dropped 0  overruns 88627471  frame 0
        TX packets 6052231212  bytes 968984191904 (902.4 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x9d120000-9d13ffff  
eno2: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST>  mtu 1500
        ether a8:c9:8a:2a:26:51  txqueuelen 1000  (Ethernet)
        RX packets 279408319  bytes 17126514964 (15.9 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 849022  bytes 50941838 (48.5 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x9d100000-9d11ffff  

# ens2f0 和 ens2f1 这两个也是以太网接口，作为bond1的从属接口（SLAVE）参与绑定。
ens2f0: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST>  mtu 1500
        ether 98:a9:2d:b1:a3:9c  txqueuelen 1000  (Ethernet)
        RX packets 349709709733  bytes 43723854128018 (39.7 TiB)
        RX errors 0  dropped 11224833  overruns 0  frame 0
        TX packets 377771137065  bytes 75028075321961 (68.2 TiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
ens2f1: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST>  mtu 1500
        ether 98:a9:2d:1b:80:16  txqueuelen 1000  (Ethernet)
        RX packets 38190413  bytes 31927160065 (29.7 GiB)
        RX errors 0  dropped 2  overruns 0  frame 0
        TX packets 845315  bytes 86661955 (82.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

# ens3f0 和 ens3f1 这两个同样是物理以太网接口，作为bond2的从属接口（SLAVE）参与绑定。
ens3f0: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST>  mtu 1500
        ether 98:a9:2d:b1:a3:9c  txqueuelen 1000  (Ethernet)
        RX packets 64588184231  bytes 8079843643396 (7.3 TiB)
        RX errors 0  dropped 2  overruns 0  frame 0
        TX packets 1896967  bytes 191602201 (182.7 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
ens3f1: flags=6211<UP,BROADCAST,RUNNING,SLAVE,MULTICAST>  mtu 1500
        ether 98:a9:2d:1b:80:16  txqueuelen 1000  (Ethernet)
        RX packets 18423536  bytes 9047596876 (8.4 GiB)
        RX errors 0  dropped 281  overruns 0  frame 0
        TX packets 1961340  bytes 198068795 (188.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

#lo 本地环回接口（Loopback interface），主要用于本机进程间的通信测试。它有IPv4和IPv6地址，并且始终处于活动状态。
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        inet6 2409:8c20:1833:2000::afb:e400  prefixlen 121  scopeid 0x0<global>
        inet6 2409:8c20:1833:2000::a01:55e  prefixlen 128  scopeid 0x0<global>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 8141925473  bytes 1070854077937 (997.3 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8141925473  bytes 1070854077937 (997.3 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


#整体上看，这台服务器配置了三个绑定接口，每个绑定由两对物理网卡组成，总共使用了六块物理网卡，同时支持IPv4和IPv6协议，并且具有Docker网络支持

在计算机网络中，"bond"指的是绑定（Bonding）技术，它是一种将两个或多个物理网络接口卡（NICs）虚拟化为一个逻辑接口的方法。通过bonding，服务器可以实现以下功能：

冗余：当其中一个物理网卡发生故障时，其他网卡可以接管通信，确保网络连接的高可用性。
负载均衡：在某些工作模式下，bonding可以将流量分散到多个网卡上，以提高带宽和处理能力。
容错：如果一个物理链路出现问题，数据包可以通过备用链路传输，从而避免网络中断。
Linux操作系统支持多种bonding模式，例如：

Mode 0 (balance-rr)：轮询负载均衡
Mode 1 (active-backup)：主备切换
Mode 2 (balance-xor)：根据XOR算法进行负载均衡
Mode 4 (802.3ad)：IEEE 802.3ad 协议，即LACP（Link Aggregation Control Protocol）
配置bond后，系统会为这些物理网卡创建一个新的虚拟接口（如bond0、bond1等），并为其分配IP地址和其他网络参数，上层应用和服务则与这个虚拟接口进行交互，而无需关心底层是单个还是多个物理网卡在提供服务。


# bond0, bond1 和 bond2 这些是绑定（Bonding）网络接口，用于将多个物理网络接口组合在一起提供冗余、负载均衡或提高带宽。它们分别被配置为主动-主动模式（MASTER），并且都处于UP状态，可以正常接收和发送数据包
#这句话描述的是Linux系统中的网络接口绑定技术（Bonding）的应用情况。在Linux中，bond0、bond1和bond2是通过 bonding 驱动创建的虚拟网络接口，这些虚拟接口分别代表了三个不同的物理网络接口组合。具体来说：
#冗余：当系统将多个物理网卡绑定在一起时，可以提供网络连接的冗余性，这意味着如果一个物理网卡发生故障，其它绑定在同一bond接口下的网卡仍能保持网络通信，从而提高了系统的可用性和稳定性。
#负载均衡：根据配置的bond模式，可以实现不同形式的负载均衡，例如轮询发送数据包到不同的物理接口上，以充分利用所有物理链路的带宽资源，提高数据传输效率。
#主动-主动模式 (MASTER)：这里提到的“主动-主动模式”通常指的是在某些bonding模式下（如balance-rr或802.3ad），所有的物理接口都是活动的，并同时参与数据传输，而不是处于备份待命状态。
#UP状态：表明这三个bond接口当前都已启用并正常工作，能够接收和发送网络数据包。
#总结来说，这段话意味着这台Linux服务器通过bonding技术，将三组不同的物理网络接口捆绑成了bond0、bond1和bond2三个逻辑网络接口，以达到增强网络稳定性和性能的目的。

bond0: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST>  mtu 1500
        ether a8:c9:8a:2a:26:51  txqueuelen 1000  (Ethernet)
        RX packets 9330959261  bytes 1162764722575 (1.0 TiB)
        RX errors 0  dropped 0  overruns 88627471  frame 0
        TX packets 6053080205  bytes 969035124898 (902.4 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

bond1: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST>  mtu 1500
        ether 98:a9:2d:b1:a3:9c  txqueuelen 1000  (Ethernet)
        RX packets 414296763996  bytes 51803255730129 (47.1 TiB)
        RX errors 0  dropped 11224973  overruns 0  frame 0
        TX packets 377771955900  bytes 75028160089205 (68.2 TiB)
        TX errors 0  dropped 12 overruns 0  carrier 0  collisions 0

bond2: flags=5187<UP,BROADCAST,RUNNING,MASTER,MULTICAST>  mtu 1500
        ether 98:a9:2d:1b:80:16  txqueuelen 1000  (Ethernet)
        RX packets 57743878  bytes 41416785102 (38.5 GiB)
        RX errors 0  dropped 278  overruns 0  frame 0
        TX packets 3884664  bytes 391551569 (373.4 MiB)
        TX errors 0  dropped 3 overruns 0  carrier 0  collisions 0



#ens2f0 和 ens2f1 这两个也是以太网接口，作为bond1的从属接口（SLAVE）参与绑定

这句话的意思是，ens2f0 和 ens2f1 是这台服务器上的两个物理以太网接口。在Linux系统中，这两个接口被配置为bonding（绑定）技术的一部分，作为从属接口（SLAVE）与名为 bond1 的逻辑接口关联。
这意味着：
ens2f0 和 ens2f1 这两个物理网络适配器共同工作，它们的带宽和功能合并到一起，表现为一个虚拟的、统一管理的网络接口 —— bond1。
bond1 接口负责处理所有通过 ens2f0 和 ens2f1 发送和接收的数据包，并可以根据bonding配置的不同模式实现冗余备份、负载均衡或其他高级功能。
在实际运行中，如果其中一个物理接口（如 ens2f0）出现问题或断开连接，由于另一个物理接口（ens2f1）仍与 bond1 绑定并处于活动状态，因此网络通信可以继续进行，从而提高了网络连接的稳定性和可用性。
ens2f0 和 ens2f1和前面的bond0，bond1，bond2什么区别?

# ens2f0 和 ens2f1 是物理以太网接口卡（NICs），它们是服务器或设备上的实际硬件网络端口，可以直接连接到网络线路传输数据。
# 而 bond0、bond1 和 bond2 则是通过Linux系统中的Bonding驱动技术创建的逻辑网络接口。这些逻辑接口是由多个物理接口组合而成的，例如在您提供的信息中：
#ens2f0 和 ens2f1 组合成了 bond1。
#其他物理接口（未在该段信息中显示）分别组成了 bond0 和 bond2。
#区别如下:
#物理接口（如 ens2f0 和 ens2f1）：直接与物理网络电缆相连，提供实际的数据通信能力。
#逻辑绑定接口（如 bond0、bond1、bond2）：由一个或多个物理接口聚合而成，表现为单个虚拟网络接口。这个虚拟接口具有更高的带宽（如果配置为负载均衡模式）、冗余（如果配置为主备切换模式）以及更灵活的网络管理特性。
#简而言之，物理接口是底层硬件资源，而逻辑绑定接口则是对这些硬件资源进行管理和优化的软件抽象层
```



## 掩码

```
NETMASK="255.255.255.0" 这个设置定义了网络掩码（Network Mask），在计算机网络中，它用来确定IP地址中的哪些部分代表网络地址，哪些部分代表主机地址。

具体到这个例子：

255.255.255.0 对应的二进制表示是 11111111 11111111 11111111 00000000。
其中连续的1表示网络部分，连续的0表示主机部分。
对于IPv4地址来说，这种掩码通常对应的是C类地址的默认子网掩码，意味着前24位用于标识网络号，后8位用于标识主机号。
例如，如果一个IP地址为 192.168.1.1 并且使用上述的子网掩码，则它的网络地址就是 192.168.1.0，在这个网络内的其他设备其IP地址的第一、第二和第三部分必须与 192.168.1 相同，而第四部分（主机部分）则可以在 0 到 255 的范围内变化。
```

## ARP

```JSON
# 同一局域网
ARP（Address Resolution Protocol，地址解析协议）是TCP/IP网络中用于在链路层（以太网、令牌环等）将IP地址映射到物理（MAC）地址的一种协议。以下是ARP地址解析的基本过程：

请求阶段：

当主机A需要与同一局域网内的主机B通信时，首先要知道主机B的MAC地址。
如果主机A的ARP缓存表中没有主机B的MAC地址记录，主机A会构造一个ARP请求广播帧，该帧中包含了目标IP地址（即主机B的IP地址）和源IP地址（主机A的IP地址），但目标MAC地址部分填充为全F（FF:FF:FF:FF:FF:FF），表示这是一个广播请求。
响应阶段：

ARP请求广播帧被同一个局域网中的所有设备接收到，包括主机B。
主机B检查ARP请求中的目标IP地址是否与自己的IP地址匹配。
若匹配，则主机B会发送一个单播ARP响应帧给主机A，其中包含了自己的MAC地址以及主机A的IP地址。
缓存记录：

主机A收到ARP响应后，提取出主机B的MAC地址，并将其存储在ARP缓存表中，以便后续可以直接使用这个MAC地址来发送数据包。
缓存中的ARP条目通常有一个有限的生存时间（TTL），过期后会自动删除或更新。
通过上述步骤，主机A成功地通过ARP协议获取到了主机B的物理地址，从而能够在数据链路层上直接与主机B进行通信。




# 不同的局域网中
ARP协议不能直接跨网络工作。如果主机A需要与不同局域网中的主机B通信，则需要通过以下方式实现：

默认网关：

如果主机A和主机B不在同一个子网（即同一局域网）内，主机A通常会将数据包发送给其默认网关（通常是路由器），因为默认网关连接了多个局域网。
主机A首先使用ARP请求获取默认网关的MAC地址，然后将目标为主机B的数据包发送给默认网关。
路由转发：

路由器收到主机A的数据包后，查看其内部的路由表以决定如何转发该数据包。
如果路由器知道如何到达主机B所在的子网，它将根据路由表更新IP头部的目的地址，并通过另一个接口将数据包发送到下一个跃点（可能是另一个路由器或主机B所在子网的交换机）。
目的地局域网的ARP解析：

数据包到达主机B所在子网后，子网内的设备（如交换机或路由器）会广播ARP请求来找到主机B的实际MAC地址。
主机B回应ARP请求，提供其MAC地址，这样数据包就可以最终送达主机B。
总结来说，在不同局域网间进行通信时，ARP主要用于本地子网内的设备寻址，而跨子网通信则依赖于路由器的路由功能和逐跳地进行ARP解析。


14:27:54.818912 ARP, Request who-has localhost.localdomain tell 192.168.241.150, length 46
14:27:54.818937 ARP, Reply localhost.localdomain is-at 00:0c:29:06:af:6a (oui Unknown), length 28
```

## ICMP ping

```
ICMP ping测试是一种利用Internet Control Message Protocol (ICMP) 的Echo请求和Echo回复消息来检测网络连通性、延迟和数据包丢失情况的方法。在命令行中，通常使用ping命令来进行这项测试。以下是一个基本的ICMP ping测试流程：

发起Ping请求： 当你在一台主机上执行ping <目标IP地址>时，本地主机将发送一个ICMP Echo请求报文到指定的目标主机。

接收Echo回复： 目标主机收到Echo请求后，会返回一个ICMP Echo回复报文给发起请求的主机。

测量指标：

连通性：如果能够接收到Echo回复，则表明两台主机之间网络是连通的。
延迟（Round-Trip Time, RTT）：根据Echo请求发出时间和Echo回复到达时间计算往返时间，即数据包在网络中传输的时间。
丢包率：如果发送了多个Echo请求但没有收到全部回复，则说明发生了数据包丢失。
持续测试： ping命令默认会持续不断地发送Echo请求，直到被手动停止（通过按Ctrl+C键中断），或者达到指定的次数或超时。



ping -c 1 192.168.241.143

tcpdump -i ens33 host 192.168.241.150
14:28:04.838077 IP 192.168.241.150 > localhost.localdomain: ICMP echo request, id 19924, seq 1, length 64
14:28:04.838179 IP localhost.localdomain > 192.168.241.150: ICMP echo reply, id 19924, seq 1, length 64
```

## 回环接口

```
这段配置信息来自于Linux系统中用于定义回环接口（Loopback Interface）的配置文件ifcfg-lo。下面是对各个配置项的解释：

DEVICE=lo: 定义了设备名称为“lo”，这是回环接口的标准设备名。

IPADDR=127.0.0.1: 为回环接口分配了IPv4地址127.0.0.1，这是一个保留地址，通常称为localhost，任何发往这个地址的数据包都会被发送给本地主机本身。

NETMASK=255.0.0.0: 网络掩码设置为255.0.0.0。在这个案例中，配置可能有误，标准的回环接口网络掩码应该是255.0.0.0/8，即255.0.0.0，但通常在现代Linux系统中会自动纠正为正确的掩码255.0.0.0（或简写为/8）。

NETWORK=127.0.0.0: 指定网络地址为127.0.0.0，这也是回环地址所在的网络段。

BROADCAST=127.255.255.255: 设置广播地址为127.255.255.255。对于回环接口而言，这个广播地址的实际作用并不明显，因为回环接口主要用于本机内部通信。

ONBOOT=yes: 表示在系统启动时自动激活此回环接口。

NAME=loopback: 给接口赋予一个友好的名称，这里命名为"loopback"，表示它是一个回环接口。

总之，ifcfg-lo 文件是用来配置和管理Linux系统中的回环网络接口的，确保在系统启动时该接口可用，并正确指定了其IP地址、网络掩码等相关属性。
```








## 1. 网络检测工具

### 1.1 traceroute

traceroute是一个用于追踪数据包从本地主机到目标主机所经过的路由（即IP地址）的命令行工具。

在Linux系统中，执行以下命令：

```
traceroute www.baidu.com
```

这将显示数据包到达`www.baidu.com`的过程中经过的所有路由器及其响应时间。每个“跳”代表一个网络节点，通常包括路由器、交换机或任何参与数据包转发的设备。

### 1.2 tcpdump

`tcpdump` 命令有很多选项和参数，以下是一些基本且常用的 `tcpdump` 命令格式及其含义：

1. **捕获所有网络流量**：

```code
tcpdump
```

这将监听默认网卡上的所有IP流量。

**指定网络接口**：

```
tcpdump -i [interface]
```

例如：`tcpdump -i eth0`，这将只捕获eth0网卡上的流量。

**过滤特定主机或网络**：

```
tcpdump host [host/IP address]
```

或者使用网络掩码来指定一个网络范围：

```
tcpdump net [network/IP address/mask]
```

**按照协议过滤**：

```
tcpdump proto [protocol]
```

如：`tcpdump proto tcp` 只捕获TCP协议的流量。

**根据端口过滤**：

```
tcpdump port [port number]
```

如：`tcpdump port 80` 仅显示HTTP（默认端口为80）相关的数据包。

**输出到文件**：

```
tcpdump -w [file]
```

将捕获的数据包保存到指定的文件中，以便后续分析。

**从文件读取并解析数据包**：

```
tcpdump -r [file]
```

**打印数据包内容**：

```
tcpdump -A
```

显示数据包的ASCII内容（如果有的话）。

**只显示匹配的数据包数**：

1. ```code
   tcpdump -c [count]
   ```

   指定捕获指定数量的数据包后停止。

这只是 `tcpdump` 命令的一部分功能，实际使用时可以根据需要组合各种选项进行更加精细的筛选和监控。在使用 `tcpdump` 时，请确保你有足够权限，并遵守相关法律法规，尤其是在生产环境中进行网络抓包时。

### 1.3 top 

### 1.4 df -h



## 2. 一台机器作为另一台机器的网关

如果143机器需要作为其他内部网络主机（如149机器）访问外部网络的网关，您需要在143机器上执行以下操作：

1. **检查143机器的网络接口和路由配置**： 确保 `ens37` 接口已连接到互联网，并且具有正确的IP地址、子网掩码和默认网关设置。

2. **启用IP转发**： IP转发已经在您的系统中启用，无需再次执行此步骤。

3. **配置NAT (网络地址转换)**： 使用iptables工具为从 `192.168.241.0/24` 子网来的流量配置SNAT（源地址转换），使其能够通过 `ens37` 接口访问外部网络。以下是示例命令：

```
# 允许转发
sudo iptables -P FORWARD ACCEPT

# 添加POSTROUTING链规则以进行SNAT
sudo iptables -t nat -A POSTROUTING -s 192.168.241.0/24 ! -d 192.168.241.0/24 -j SNAT --to-source 192.168.1.8
```
上述命令会将来自 `192.168.241.0/24` 子网并要发送到外部网络的数据包的源地址转换为 `192.168.1.8`。
**保存iptables规则**： 在某些Linux发行版中，重启后iptables规则可能会丢失，所以需要确保规则被持久化保存。方法如下：

对于RHEL/CentOS 7及以前版本：
  ```
  bash
  sudo service iptables save
  ```
对于较新版本或需要手动保存的情况：

1. ```bash
   sudo iptables-save > /etc/sysconfig/iptables
   ```
   
2. **确认防火墙策略**： 虽然您提到firewalld已经关闭，但还需确保没有其他的防火墙规则阻止了数据包的转发。如果您使用的是iptables以外的防火墙管理工具，请根据对应工具文档进行相应配置。

3. ```bash
   若是直接修改的iptables，则需要执行下面的文件时iptables生效
   
   # 使用iptables直接应用规则
   sudo iptables-restore < /etc/sysconfig/iptables
   ```



完成上述步骤后，理论上149机器应该可以通过143机器访问外部网络。但是请注意，实际环境可能有额外的安全性和网络架构考量，务必谨慎配置。

```text
还有配一下
#打开路由转发功能
[root@stache31 ~]# echo 'net.ipv4.ip_forward = 1' >> /etc/sysctl.conf
[root@stache31 ~]# sysctl -p
再检查一下/etc/resolv.conf文件中是否设置nameserver
```



## gpt

### 你的主机与你主机设定的 Gateway 必定是在同一个网段内

是的，您的理解完全正确。在一个网络环境中，主机（计算机或设备）与它配置的网关（Gateway）通常必须位于同一个IP子网内。这是因为网关的主要作用是提供主机访问其他子网或者外部网络（如Internet）的能力，而要实现这一点，主机与网关之间必须能够直接通过二层交换进行通信，也就是说它们的IP地址需要满足同一子网掩码下的网络部分相同。

例如，如果一台主机的IP地址是192.168.1.100，子网掩码是255.255.255.0，那么它的网关地址应该形如192.168.1.xxx，这样才能确保它们处于同一子网中，主机可以通过网关发送数据包到其他子网或外部网络。

### 不同网段的默认网关怎么联系的

不同网段的默认网关通常是通过路由器来相互联系的。在计算机网络中，每个子网（或网段）都有一个默认网关，它是一个设备接口的IP地址，这个设备通常是一个路由器。当主机需要发送数据包到非本子网的目标地址时，它会将数据包发送给其配置的默认网关。

路由器作为不同网段之间的连接点，具备转发数据包的功能。路由器上至少有两个接口（甚至更多），分别与不同的网段相连，并为每个接口分配相应的IP地址，使其成为相应网段内的有效网关。

例如：

- 网络A的IP地址范围是192.168.1.0/24，其默认网关可能是192.168.1.254；
- 网络B的IP地址范围是192.168.2.0/24，其默认网关可能是192.168.2.254。

若要从网络A中的主机向网络B中的主机发送数据，数据包首先会被发送至网络A的默认网关（即路由器上的接口A）。路由器收到数据包后，根据路由表的信息判断目标地址属于另一个网段，于是将数据包从其接口B转发出去，最终到达网络B的主机。这样就实现了不同网段之间通过各自的默认网关（路由器）进行通信。

### 192.168.1.254和192.168.2.254这两个网关在一个机器上吗

192.168.1.254和192.168.2.254这两个IP地址可以分配给同一台机器上的不同网络接口，但这通常取决于这台机器是否配置为路由器或有多个网络适配器，并且这些网络适配器连接到不同的子网。

在实际的网络环境中，如果一台设备（如路由器）同时作为两个不同子网（192.168.1.0/24和192.168.2.0/24）的网关，那么它可能会有两个接口，分别设置这两个IP地址。一个接口面向192.168.1.x网络的设备，另一个接口面向192.168.2.x网络的设备。这样，该设备就能够根据路由规则，在两个子网之间转发数据包。

但是，对于普通计算机而言，它们通常只有一个网络接口（除非额外安装了多块网卡），因此在同一台机器上通常不会同时看到192.168.1.254和192.168.2.254两个默认网关地址。

### 网络适配器是什么

网络适配器（Network Adapter）也被称为网卡（Network Interface Card, NIC），是计算机硬件设备的一部分，它的主要功能是将计算机连接到网络中。在台式机、笔记本电脑或服务器等设备内部，网络适配器通常是以插卡的形式存在；而在一些移动设备如智能手机和平板电脑中，则通常是集成在主板上的芯片。

网络适配器提供了物理层和数据链路层的协议支持，使得计算机可以通过有线（如以太网）或无线（如Wi-Fi、蓝牙）方式与其他网络设备进行通信。它能够将计算机中的数字信号转换为可以在网络上传输的电信号，并且还能接收外部网络传输来的电信号并解码成计算机可以理解的数据。

在网络配置中，每个网络适配器都有一个唯一的MAC地址（Media Access Control Address），并且可以根据需要配置IP地址和其他相关的网络参数，以便于设备接入并参与特定的网络环境。